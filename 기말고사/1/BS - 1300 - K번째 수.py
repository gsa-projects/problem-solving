n = int(input())    # 배열 A는 n*n 크기
k = int(input())    # B[k]를 구해보자.

# n = 3일 때 A
# 1 2 3
# 2 4 6
# 3 8 9
# n = 3일 때 B
# 1 2 2 3 3 4 6 8 9

# n = 4일 때 A
# 1 2 3 4
# 2 4 6 8
# 3 6 9 12
# 4 8 1216
# n = 4일 때 B
# 1 2 2 3 3 4 4 4 6 6 8 8 9 12 12 16 ...

# k는 알고 있는데 B[k]를 구하라는 상황
#   -> B[mid] 로부터 mid를 구해 k와 비교

def get_x_from_value(val):
    # 만약 val이 4면 x를 구하는 방법
    # [1 2 3 4]
    # [2 4] 6 8
    # [3] 6 9 12
    # [4] 8 1216
    # 각 행에서 4보다 작은 수들 구해서 전부 더하면 그 인덱스가 x 바로 다음 인덱스임
    # 4 // 1 + 4 // 2 + 4 // 3 + 4 // 4 = 4 + 2 + 1 + 1 = 8
    # n = 3인데 val이 4면 4 // 1 + 4 // 2 + 4 // 3

    ret = 0
    for i in range(1, n + 1):
        ret += min(n, val // i)     # note: n = 4인데 val = 15면 15//1 + 15//2 가 되는데 실제로는 각 행에서 최대 4개씩 얻을 수 있으니까 상한 필요
    return ret

# k의 min, max
# 1 <= k < n**2 이긴 한데 B[k] <= k가 자명하므로(B[n**2] = n**2이고 그 1<x<n**2은 항상 조금 작음) 최대는 k
i, j = 1, k     # B[k] 축
result = -1

while i <= j:
    m = (i + j) // 2    # B[x]
    x = get_x_from_value(m)     # x 후보들 + 1 (ex. 3 4 4 4 4 5 면 지금 B[x] = 4일 때 얘는 5를 가리킨다는 뜻)

    # B[k]와 k의 증가 방향은 동일
    # 지금 x가 x 후보들 + 1이므로 항상 구하고자 하는 x들보다 큰 상황. 계속 감소시켜야 함
    # n = 3 -> 1 2 2 3 3 4 4 4 6 6 8 8 9 ...
    # get_x_from_value(6) = 11, B[11] = 8 처음 나오는 경우 (6 다 넘기고 바로)
    # 즉, 어지저찌 x == k 만들었다고 해도 x = get_x_from_value(m)로부터
    # m을 처음으로 넘는 값의 인덱스 x가 나왔기 때문에 B[x] > m 이라서 x가 더 큼 -> 최소인 x를 찾아

    if x < k:
        i = m + 1
    elif k <= x:
        result = m
        # print('B[x] =', i, m, j)
        # print('k =', k, 'x =', x)
        j = m - 1

print(result)
